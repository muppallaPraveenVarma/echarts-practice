"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const api_extractor_model_1 = require("@microsoft/api-extractor-model");
const VisitorState_1 = require("./VisitorState");
const node_core_library_1 = require("@microsoft/node-core-library");
class DeclarationMetadata {
    constructor() {
        /**
         * This is the original TSDoc comment parsed from the source code.
         * It may be modified (or constructed artificially) by the DocCommentEnhancer.
         */
        this.tsdocComment = undefined;
        /**
         * The ParserContext from when the TSDoc comment was parsed from the source code.
         * If the source code did not contain a doc comment, then this will be undefined.
         */
        this.tsdocParserContext = undefined;
        /**
         * This is the release tag that was explicitly specified in the original doc comment, if any.
         */
        this.declaredReleaseTag = api_extractor_model_1.ReleaseTag.None;
        /**
         * The "effective" release tag is a normalized value that is based on `declaredReleaseTag`,
         * but may be inherited from a parent, or corrected if the declared value was somehow invalid.
         * When actually trimming .d.ts files or generating docs, API Extractor uses the "effective" value
         * instead of the "declared" value.
         */
        this.effectiveReleaseTag = api_extractor_model_1.ReleaseTag.None;
        // NOTE: In the future, the Collector may infer or error-correct some of these states.
        // Generators should rely on these instead of tsdocComment.modifierTagSet.
        this.isEventProperty = false;
        this.isOverride = false;
        this.isSealed = false;
        this.isVirtual = false;
        this.isPreapproved = false;
        // Assigned by DocCommentEnhancer
        this.needsDocumentation = true;
        // If true, then it would be redundant to show this release tag
        this.releaseTagSameAsParent = false;
        this.docCommentEnhancerVisitorState = VisitorState_1.VisitorState.Unvisited;
        /**
         * If true, then this declaration is treated as part of another declaration.
         */
        this.isAncillary = false;
        /**
         * A list of other declarations that are treated as being part of this declaration.  For example, a property
         * getter/setter pair will be treated as a single API item, with the setter being treated as ancillary to the getter.
         *
         * If the `ancillaryDeclarations` array is non-empty, then `isAncillary` will be false for this declaration,
         * and `isAncillary` will be true for all the array items.
         */
        this.ancillaryDeclarations = [];
    }
    addAncillaryDeclaration(otherDeclaration) {
        const otherMetadata = otherDeclaration.metadata;
        if (!otherMetadata) {
            throw new node_core_library_1.InternalError('addAncillaryDeclaration() cannot be called before the declaration metadata is solved');
        }
        if (this.ancillaryDeclarations.indexOf(otherDeclaration) >= 0) {
            return; // already added
        }
        if (this.isAncillary) {
            throw new node_core_library_1.InternalError('Invalid call to addAncillaryDeclaration() because the target is ancillary itself');
        }
        if (otherMetadata.isAncillary) {
            throw new node_core_library_1.InternalError('Invalid call to addAncillaryDeclaration() because source is already ancillary to another declaration');
        }
        otherMetadata.isAncillary = true;
        this.ancillaryDeclarations.push(otherDeclaration);
    }
}
exports.DeclarationMetadata = DeclarationMetadata;
//# sourceMappingURL=DeclarationMetadata.js.map